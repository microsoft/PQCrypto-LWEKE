# Creative Commons Zero v1.0 Universal
# SPDX-License-Identifier: CC0-1.0
# Created by Douglas Stebila

import os
from frodokem import FrodoKEM

class NISTKAT(object):
    
    @staticmethod
    def run(kem):
        """Generate a NIST KAT output for the given KEM"""
        rng = NISTKAT.NISTRNG()
        kem.randombytes = rng.randombytes
        print("===============================================")
        print(kem.variant)
        print("count = 0")
        print("seed = <unspecified>")
        (pk, sk) = kem.kem_keygen()
        print("pk =", pk.hex().upper())
        print("sk =", sk.hex().upper())
        (ct, ss_e) = kem.kem_encaps(pk)
        print("ct =", ct.hex().upper())
        print("ss =", ss_e.hex().upper())
        ss_d = kem.kem_decaps(sk, ct)
        assert ss_e.hex() == ss_d.hex(), "Shared secrets not equal"
        return {
            'variant': kem.variant,
            'count': '0',
            'seed': '<unspecified>',
            'pk': pk.hex().upper(),
            'sk': sk.hex().upper(),
            'ct': ct.hex().upper(),
            'ss': ss_e.hex().upper()
        }
    
    def check(katvalues, katfile):
        """Check that KAT values in the dictionary katvalues match those stored in katfile"""
        with open(os.path.join('..', 'KAT', katfile), 'r') as fh:
            basekatvalues = dict()
            basekatvalues['variant'] = fh.readline().replace('#', '').strip()
            fh.readline()
            # count
            a = fh.readline().strip().replace(' = ', ',').split(',')
            basekatvalues[a[0]] = a[1]
            # seed
            a = fh.readline().strip().replace(' = ', ',').split(',')
            basekatvalues[a[0]] = a[1]
            # pk
            a = fh.readline().strip().replace(' = ', ',').split(',')
            basekatvalues[a[0]] = a[1]
            # sk
            a = fh.readline().strip().replace(' = ', ',').split(',')
            basekatvalues[a[0]] = a[1]
            # ct
            a = fh.readline().strip().replace(' = ', ',').split(',')
            basekatvalues[a[0]] = a[1]
            # ss
            a = fh.readline().strip().replace(' = ', ',').split(',')
            basekatvalues[a[0]] = a[1]
            for x in ['variant', 'count', 'pk', 'sk', 'ct', 'ss']:
                assert katvalues[x] == basekatvalues[x], "{:s} not equal".format(x)
            print("Computed KAT values match for {:s}".format(basekatvalues['variant']))

    class NISTRNG(object):
        """Dummy object that contains a serialization of the randombytes outputs that 
        would be generated by the deterministic RNG in the NIST KAT generation algorithm 
        when run on FrodoKEM; note that this is not a proper implementation of that RNG, 
        it has the exact values generated hard-coded."""

        # To get these values, add the following lines to rng.c in the C implementation to print out the required RNG outputs:
        #     printf("randombytes_output (%llu): ", xlen_original);
        #    for (size_t i = 0; i < xlen_original; i++) {
        #        printf("%02X", x[i]);
        #    }
        #    printf("\n");

        def __init__(self):
            self.current_outputs = None
            self.possible_outputs = [
                [
                    bytes.fromhex('7C9935A0B07694AA0C6D10E4DB6B1ADD2FD81A25CCB148032DCD739936737F2DB505D7CFAD1B497499323C8686325E4792F267AAFA3F87CA60D01CB54F29202A'),
                    bytes.fromhex('EB4A7C66EF4EBA2DDB38C88D8BC706B1D639002198172A7B1942ECA8F6C001BA26202BEE59AC275484EA767D41D8D357'),
                ],
                [
                    bytes.fromhex('7C9935A0B07694AA0C6D10E4DB6B1ADD2FD81A25CCB148032DCD739936737F2DB505D7CFAD1B497499323C8686325E4792F267AAFA3F87CA60D01CB54F29202A3E784CCB7EBCDCFD45542B7F6AF778742E0F4479175084AA'),
                    bytes.fromhex('EE716762C15E3B72AA7650A63B9A510040B03C0FE70475C0463BBC45A0BA5B7980DD46EEF82FB062035077D042F306BB6391040E0DD965F1FDA9D183CA9FCCB48FC010B184AB0033'),
                ],
                [
                    bytes.fromhex('7C9935A0B07694AA0C6D10E4DB6B1ADD2FD81A25CCB148032DCD739936737F2DB505D7CFAD1B497499323C8686325E4792F267AAFA3F87CA60D01CB54F29202A3E784CCB7EBCDCFD45542B7F6AF778742E0F4479175084AA488B3B74340678AA38E22E9628B0A161FDEB0BD252173B9C'),
                    bytes.fromhex('9F08587687FF66765C671DE73E918D2823CA573FF4E7A31A9160324026E540EACB3A04E0D54C75DEB9705BFDFBDF935A7528802EE6E5B0C6A73B2B761D9BD0848A6E4CF3FC4CA84F14E0331AF35BFEF41E42B13A6DAE6DF937F738C1857BA1CA'),
                ],
            ]
        
        def randombytes(self, n):
            # On each use, check if the output length requested matches one of the pre-programmed values
            if self.current_outputs == None:
                for i in range(len(self.possible_outputs)):
                    if n == len(self.possible_outputs[i][0]):
                        self.current_outputs = self.possible_outputs[i]
                assert self.current_outputs != None, "Could not find pre-programmed output of desired length {:d}".format(n)
            assert len(self.current_outputs) > 0, "No remaining outputs available"
            assert n == len(self.current_outputs[0]), "Next output not of the appropriate length"
            r = self.current_outputs.pop(0)
            return r

if __name__ == "__main__":
    # Run KATs for all supported FrodoKEM variants
    katvalues = NISTKAT.run(FrodoKEM('FrodoKEM-640-AES'))
    NISTKAT.check(katvalues, 'PQCkemKAT_19888.rsp')
    katvalues = NISTKAT.run(FrodoKEM('FrodoKEM-640-SHAKE'))
    NISTKAT.check(katvalues, 'PQCkemKAT_19888_shake.rsp')
    katvalues = NISTKAT.run(FrodoKEM('FrodoKEM-976-AES'))
    NISTKAT.check(katvalues, 'PQCkemKAT_31296.rsp')
    katvalues = NISTKAT.run(FrodoKEM('FrodoKEM-976-SHAKE'))
    NISTKAT.check(katvalues, 'PQCkemKAT_31296_shake.rsp')
    katvalues = NISTKAT.run(FrodoKEM('FrodoKEM-1344-AES'))
    NISTKAT.check(katvalues, 'PQCkemKAT_43088.rsp')
    katvalues = NISTKAT.run(FrodoKEM('FrodoKEM-1344-SHAKE'))
    NISTKAT.check(katvalues, 'PQCkemKAT_43088_shake.rsp')
